---
layout: post
title: Malware Strings
date: 2025-11-09
jumbotron: Malware String
regular_date: November 9, 2025
summary:  There are strings in the human heart that had better not be vibrated. Charles Dickens
---

<figure style="text-align:center;">
<img src="https://s3.amazonaws.com/NARAprodstorage/opastorage/live/71/2071/32207171/content/kansas-city/rg-075/285796/75-SR-6463_001.jpg" 
     alt="stock photo of books from the National Archives (identifier 146150242)" 
     title="Air Compressor Hammer Breaking Rock Ledge" 
     style="width:70%; height:auto;" />
     <figcaption style="font-style: italic; margin-top: 10px;">
          This blog posts discusses API Hammering, so this post has a picture of an air compressor hammer (NAID 32207171)
     </figcaption>
</figure>

---
### Jump to Section
{:.no_toc}
* TOC
{:toc}
--- 

### std::string
First, we need to understand how strings work. In C++, there's a short and long layout.  In the short string layout, the entire string is placed on the stack. The first byte is reserved for the string size; the least significant bit indicates whether it's short or long format.  After the reserved byte, next follows a 16-bit array.  In the long format, the pointer points to the location on the heap where the actual string is stored. In both forms, C++ keeps track of the string size.

Understanding string layout is important because in the decompiler, you'll see the underlying components. Identifying and labelling them will help understand how the malware constructs its string, and it will facilitate deobfuscating / decrypting strings. 

Do the C++ string layouts correspond to the assembly layouts?  ChatGPT said no.  I wondered this after reading that assembly also has two ways of denoting strings.  For instance, The Art of 64-Bit Assembly Vol I notes that there are zero-terminated strings and length-prefixed strings. "Most of the time, an assembly language program won't directly work with strings appearing in the .data (or .const or .data?) section," but rather the program will work with the string pointer.  

### Things I Learned
There's no need for FLOSS because Ghidra will show you all the strings. You can even write scripts to decrypt or decode them.  Watching YouTube videos of experienced folks analyze malware is so incredibly helpful. 

### Malware Encryption:

Six months ago, I read a wonderful blog or Medium post about encryption in malware. I cannot recall or locate it. I found [this from Intezer](https://intezer.com/blog/unraveling-malware-encryption-secrets/), and it's okay. In any event, the next section of the course is encryption.  I'll try to find that post.  



### Tidbits

"the Microsoft ABI is a construct between modules in a program to ensure compatibility (between modules, especially modules written in different programming languages)"

"The Windows API functions are all written in C++ code, so calls to Windows must respect the Windows ABI."

p. 35, The Art of 64-Bit Assembly, Volume I, Randall Hyde

**Future Blog Post Ideas**
* [Memory Only Malware](https://medium.com/@d3lt4labs/hunting-memory-only-malware-with-att-ck-and-yara-de68756f3274)

* How do malware fingerprint hosts?