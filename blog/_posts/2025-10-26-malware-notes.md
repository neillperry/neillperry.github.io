---
layout: post
title: Getting Started
date: 2025-10-27
jumbotron: Getting Started
regular_date: October 27, 2025
summary:  New Course on Intermediate Malware Analysis
---

<figure style="text-align:center;">
<img src="https://s3.amazonaws.com/NARAprodstorage/opastorage/live/77/4993/45499377/content/stillpix/165-ww/Box269/FolderB/165-WW-269B-044.jpg" 
     alt="Black and white photograph from the National Archives (identifier 45499377), showing two nurses masked up during the Influenza Epidemic of 1918" 
     style="width:75%; height:auto;" />
     <figcaption style="font-style: italic; margin-top: 10px;">
          The National Archives doesn't have many malware analysis photographs so I'm resorting to photographs about actual viruses.
     </figcaption>
</figure>

---
### Jump to Section
{:.no_toc}
* TOC
{:toc}
--- 


### Entry point vs Main

**[What is the difference between entry and main?](https://medium.com/@greg-chapman/reveng-01-finding-main-in-32cdb8e1e9b5)**

Entry is the start of the compiler code. Main is the main() function in your code.

To find `main()` in [Visual Studio compiled code](https://www.youtube.com/shorts/t-maUnXLSu8), look for three pushes before a function call; arg c, arg v, env p



### Calling Conventions:

[Wikipedia has an article on x86](https://en.wikipedia.org/wiki/X86_calling_conventions) calling conventions. These conventions define how parameters are passed to a function and how the stack prepares for and recovers after a function is invoked. It's all part of something called the application binary tree (ABI). 

This seems like it defines the relationship between function and stack, such as divvying up the chore of cleaning up the stack. 

You could do worse than just reading all the Microsoft documentation. From that documentation on [Visual C/C++ calling conventions:](https://learn.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-170)

* **_cdecl**: the default convention for C/C++. Arguments passed onto the stack in right to left order; the calling function, aka, the caller, pops the arguments from the stack. Return variable placed in EAX.  Caller also cleans the stack. 
* **_clrcall**: Microsoft specific, used for all virtual functions that will only be called from managed code;
* **_stdcall**: Microsoft specific, used to call Win32 API functions; arguments passed onto stack, callee cleans the stack inside the function itself; Microsoft uses it for all fixed-argument functions from shared libraries (DLL)
* **_fastcall**: specifices that up to two arguments to functions are to be passed to registers (ECX and EDX), when possible. There can be other function arguments passed via stack. Optimized for compiler, i.e., that's why they call it fast. Callee cleanup.  The default convention for x64 ABI.
* **_thiscall**: Microsoft specific, default convention for member functions that don't use arguments.  (member function bleongs to a class that is designed to operate on the class's data members).  The "this" pointer is added by default. 
* **_vectorcall**: arguments passed via registers (whenever possible), but uses more registers than fastcall



### What's the point of calling conventions

To identify functions.  Decompilers sometimes get it wrong, so it's up to me to save the day.  

In the assembly code, you can spot the distinguish between caller / callee clean up functions.  


Caller Clean Up:


`CALL <function>`
`ADD ESP, <num>   ; add bytes to the ESP, stack pointer`


Callee Clean Up:
`RET <num>  ; number indicates how much of the stack needs to be cleaned`


### Volatile vs Non-Volatile Registers

"Volatile registers are scratch register presumed to be destroyed across a (function) call; not saved by the callee" whereas a nonvolatile registers are saved and retain values "across a function call" -- [IBM documentation](https://www.ibm.com/docs/en/aix/7.2.0?topic=overview-register-usage-conventions).  The Art of 64-Bit Assembly has a table of which registers Microsoft ABI designates as volatile and nonvolatile. 


### Shadow Store

> "[T]he Microsoft calling convention requires the caller to allocate storage for four parameters on the stack even if the procedure doesnâ€™t have four parameters (or any parameters at all). 

The Art of 64-Bit Assembly

* allocate 32 bytes

> sub rsp, 20h ; allocate 32 bytes 
> mov rcx, a   ; param 1
> mov rdx, b   ; param 2
> mov r8, c    ; param 3
> mov r9, d    ; param 4


"Any parameters beyond the first four must be stored on the stack after the shadow store before the call." [x64 Calling Conventions](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170) So 4 is the minimum allocation. 

### Epilogue

Discovered this outstanding article that surveys the Linux malware landscape:
[Understanding Linux Malware](https://ieeexplore.ieee.org/document/8418602), by Cozzi, Graziano, Fratantonio, Balzarotti.

That paper mentions the [Malware Must Die!](https://blog.malwaremustdie.org/) website, which is a repository of Linux malware analysis.  


Hattori Hanzo once said that, "Revenge is never a straight line. It's a forest, And like a forest it's easy to lose your way." Malware analysis is like that. There's so much information out there. There are gobs and gobs of documentation, educational resources, YouTube channels, etc.  The challenge isn't finding the knowledge, it's the discipline to commit to consistent study. Don't worry about the forest, focus on the tree in front of you.  
